#ifndef CHAPTER_17_LEXER_HPP
#define CHAPTER_17_LEXER_HPP

#include "token.hpp"
#include <istream>
#include <ostream>
#include <string>

/* The definition of Lexer is going to have many similarities with the
 * definition of Token; members are declared much the same way, for instance.
 * We'll comment only on the things that change.
 */

struct Lexer {
    /* The first change is that apart from member variables, our lexer will have
     * member functions.  We've seen member functions before, though we never
     * called them that: when we have an std::vector<int> v and call v.size(),
     * we are calling a member function; same when we have an std::string str
     * and call str.find('x').  Member functions take parameters just like
     * normal functions do, but they have an extra implicit parameter: when we
     * call v.size(), size can implicitly access everything in v.
     *
     * Let's decide what member functions we want: we'd like to be able to
     * create a Lexer from an std::istream&, get the next token, check if
     * there are any more tokens, and get the current position in the input.
     */

    // So far, we have been using the Token{x, y} syntax to specify the members
    // one-by-one; with our Lexer, this won't work because we don't want people
    // to know about most of our members.  We will define a constructor: this is
    // a special member function which is called when we create an instance.  It
    // has no return type and has the same name as the type it is a constructor
    // of.
    //
    // We can also choose whether to require the constructor to be called
    // explicitly or implicitly.  The default is implicit; this means that if we
    // have a function taking a Lexer, we can give it an std::istream& and a
    // temporary Lexer will be automatically created.  We probably don't want
    // this, so let's disable it here.
    explicit Lexer(std::istream& is);
    // We can now use Lexer lex{std::cin}; to create a lexer called lex.
    // However, we cannot use Lexer lex; anymore.  Usually, a constructor taking
    // no parameters (also called a default-constructor) is auto-generated by
    // the compiler, but defining your own constructor disables that.  We could
    // define a custom default-constructor by defining a constructor that can be
    // called with no arguments, but we choose not to do so here.

    // We don't want our Lexer to be copyable: in fact, if it were easy to do,
    // we'd like the lexer to be the only thing that could do anything with the
    // input stream we gave it.  Unfortunately, there's no easy way of achieving
    // that, but making sure we don't accidentally copy our lexer is a good
    // begin.
    //
    // In order to prohibit copying, we delete the copy-constructor.  This is a
    // constructor that takes a reference to a const instance of the type it is
    // constructing.  A deletion looks much like a declaration:
    Lexer(Lexer const&) = delete;
    // Of course, there will be no accompanying definition.

    // Extract and return the next token.
    Token extract();

    /* We'd like to return position information, but how do we best do this?  We
     * could define separate get_line and get_column member functions, but the
     * two are likely to be used together, so we can create another type to
     * store a line and a column.
     */

    struct Position {
        int line, column;
    };

    // Getting the position shouldn't change the state of our lexer.  This means
    // that even if we have a Lexer const, we should still be able to call
    // get_position on it.  We can allow this by adding const to the end of the
    // member function declaration; this is part of the function's type.  The
    // compiler will check that we don't accidentally modify the Lexer.
    //
    // Whether you add const or not is a question much like whether to add it
    // when you pass something by reference.  Adding it gives you more freedom
    // to use this function, but means the function can do less.  As more
    // features are introduced the choice becomes harder, but for now we can
    // make fairly good judgements about what does and doesn't modify the lexer.
    Position get_position() const;

    // This is a conversion operator.  We will use it much like we used
    // std::cin's conversion to bool: if it returns true, it means we can
    // extract at least one more token.
    //
    // The explicit here means that it will only trigger when we really want a
    // bool.  Normally, bools can convert to ints, and so we could accidentally
    // end up converting our Lexer to an int.  If we ever did that it would
    // probably be a mistake, so we don't allow it.
    explicit operator bool() const;

    /* We've now defined our external interface.  However, we've not yet defined
     * any of the data our Lexer contains.  We don't want people to rely on how
     * we represent our state, so we mark it as private.  This means that most
     * functions can't access it: at the moment, only Lexer's member functions
     * are given access.  We can expand this access by making a function a
     * friend, but we don't need to yet.
     */

    // This is how we specify that all members past this point are private.  If
    // we want to give everyone access again, we can instead say "public:".
    // public is the default access level for types declared as structs.  We
    // could have used "class" instead of "struct" when defining Lexer, which
    // would make the default access level private.
private:
    /* So far we've been using fairly short and non-descriptive names for our
     * variables.  For things local to a short function, that may be acceptable:
     * seeing how it is defined is often enough to judge.  However, once a
     * variable is used in many places, it pays off to give it a clearer name.
     * Notice that we've already been doing this with function names.
     */

    // Remember how once a reference was bound to something, we couldn't rebind
    // it?  A consequence of this is that we cannot assign a Lexer to another
    // Lexer.  We can still copy it, though.
    std::istream& input_stream;

    // We can specify initial values for our members.  Here it matters little,
    // as we could have just written them in the constructor, but this way is
    // easier if there are multiple constructors.
    Position current_position{1, 1};

    /* Sometimes we want a member function to be private.  In this case, we'd
     * like to have a few helper functions to work with the input stream for us.
     * All further operations will be in terms of these functions.
     */

    // Try to get the next character in the stream: if that succeeds, assign it
    // to c, otherwise leave c unchanged.  Return whether it succeeded.
    bool peek(char& c) const;

    // Ignore a single character.
    //
    // This is an interesting case when it comes to const.  Strictly speaking,
    // as we have a reference to an std::istream, we could make this function
    // const.  Intuitively, we can see that it does modify the lexer state, so
    // we don't mark it const.
    //
    // More formally, if two functions don't modify an instance's state, the
    // order in which we call them should not matter.  Were ignore to be const,
    // we would expect that given a Lexer lex, lex.ignore(); lex.peek(c); would
    // give the same result as lex.peek(c); lex.ignore();.  However, the two are
    // obviously different, so marking ignore as const would be misleading.
    void ignore();

    // Same as peek_raw, except that the character is also dropped.
    bool get(char& c);

    // Ignore characters until a non-whitespace character is encountered.
    void ignore_whitespace();

    /* Our old lex_* functions will be here, too, and do the same thing as
     * before.
     */

    Token lex_name();
    Token lex_number();
    Token lex_operator();
};

// This goes well together with operator bool; it lets us do !lex.
bool operator!(Lexer const& lex);

/* A little more about the :: operator.  It is called the scope resolution
 * operator, and we use it when we want to specify a name that is defined within
 * some other entity.  We've seen that types can contain a variety of members.
 * When we want to say "member X of type Y", we write "Y::X".  This doesn't
 * always make sense: for example, you can't access a member variable without an
 * instance.  However, it does make sense for types.
 *
 * Thus, when we wish to use the Position type, which we defined inside Lexer,
 * we simply say Lexer::Position.
 */

bool operator==(Lexer::Position lhs, Lexer::Position rhs);
bool operator!=(Lexer::Position lhs, Lexer::Position rhs);
std::ostream& operator<<(std::ostream& os, Lexer::Position pos);

/* Continue to lexer.cpp to see how we implement all this.
 */

#endif
